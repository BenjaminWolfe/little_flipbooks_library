---
title: "Proposed code parsing for flipbooks"
author: "Gina Reynolds, May 2019"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: ["kunoichi", "ninjutsu"]
    nature:
      ratio: 16:10
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---


# Parse code


```{r}
parse_code <- function(code) { 
  
  tibble(code = code) %>% 
    mutate(user_reveal = str_detect(code, "#REVEAL")) %>% # Handle user defined pause points
    mutate(code = str_remove(code, "#REVEAL")) %>% # pull out any comments
    separate(col = code, into = c("code", "comment"), sep = "#") %>% 
    mutate(comment = str_trim(comment)) %>% 
    mutate(comment = paste0("  # ", comment)) %>%  
    mutate(comment = ifelse("  # NA" == comment, "", comment)) %>% 
    mutate(code = str_remove(code, "\\s+$")) %>% 
    mutate(connector = str_extract(code, "%>%$|\\+$|->$")) %>% 
    mutate(connector = replace_na(connector, "")) %>% 
    mutate(code = str_remove(code, "%>%$|\\+$|->$")) %>% 
    mutate(num_open_par = str_count(code, "\\(|\\{|\\[")) %>% # Counting open parentheses
    mutate(num_closed_par = str_count(code, "\\)|\\}|\\]")) %>%  # Counting closed parentheses
    mutate(balanced_par = (cumsum(num_open_par) - cumsum(num_closed_par)) == 0 &
             code != "")
  
}
```

```{r}
library(gapminder)
library(tidyverse)
```

# Example code

```{r the_code, eval = F}
gapminder %>%             # the data  #REVEAL
  filter(year == (2000 + 7)) %>%  # subset 
  ggplot() +              # pipe to ggplot 
  aes(x = gdpPercap) +
  aes(y = lifeExp) +  
  # Describing what follows
  geom_point() + #REVEAL
  aes(color = 
        paste("continent", 
        continent) 
          ) ->  
my_plot 
```


```{r}
local_code <- "gapminder %>%             # the data  #REVEAL
  filter(year == (2000 + 7)) %>%  # subset 
  ggplot() +              # pipe to ggplot 
  aes(x = gdpPercap) +
  aes(y = lifeExp) +  
  # Describing what follows
  geom_point() + #REVEAL
  aes(color = 
  paste(\"continent\", 
        continent) 
          ) ->  
my_plot "
```


---

```{r}
knitr:::knit_code$get("the_code")
```

---

# use parse_code() to pull apart example code

```{r}
parse_code(knitr:::knit_code$get("the_code")) %>% 
  knitr::kable()

parse_code(str_split(local_code, "\n")[[1]])

the_parsed <- parse_code(knitr:::knit_code$get("the_code"))

```



```{r}
break_points <- function(the_parsed_code_df, user_reveal_defined = F) {
  
  parsed <- the_parsed_code_df
  
  if (user_reveal_defined == F) {
    
    breaks <- parsed$balanced_par
    
  } else {
    
    breaks <- parsed$user_reveal
    
  }
  
  (1:length(breaks))[breaks]
  
}

break_points(the_parsed)

break_points(the_parsed) ->
  my_break_points
```



```{r}
highlighting <- function(the_break_points){
  
  highlight <- list()
  
  for (i in 1:length(the_break_points)) {
    if (i == 1) {  
      highlight[[i]] <- 1:the_break_points[i]
    } else {
      highlight[[i]] <- (the_break_points[i - 1] + 1):the_break_points[i]
    }
  }

  highlight
}

highlighting(my_break_points) 
highlighting(my_break_points) ->
  my_highlighting
```

```{r emi_reveal}
# reveal lines up to `upto` and highlight lines `highlight`
emi_reveal <- function(name, upto, highlight) {
content <- knitr:::knit_code$get(name)
  content[upto] <- gsub("+", "", content[upto], fixed=T)
  content[highlight] <- paste(content[highlight], "#<<")
  content[1:upto]
} 

emi_reveal("the_code", 4, 4)

```


```{r}
reveal <- function(chunk_name, upto, highlight) {
  content <- knitr:::knit_code$get(chunk_name)
  parse_code(code = content) %>% 
    mutate(reveal = 1:n() <= upto) %>% 
    filter(reveal) %>% 
    mutate(connector = case_when(1:n() == n() ~ "",
                                 1:n() != n() ~ connector)) %>% 
    mutate(highlight = ifelse(1:n() %in% highlight, "#<<", ""
                              )) %>% 
    mutate(out = paste0(code, "", connector, "", comment, highlight)) %>% 
    select(out) ->
    up_to_result
  up_to_result$out
}
```

# reveal example


```{r}
reveal("the_code", my_break_points[7], my_highlighting[[7]])
```



```{r}
partial_knit_chunks <- function(chunk_name, the_break_points, the_highlighting, show_code = T) {
  # Create slide for lines 1:N for each line N in the given chunk
  # break_points <- seq_along(knitr:::knit_code$get(chunk_name)) # original code, breaks for each line
  
  if (show_code == T) {
  partial_knit_steps <- glue::glue(
    "class: split-40",
    "count: false",
    "",
    ".column[.content[",
    "```{r plot_{{chunk_name}}_{{the_break_points}}, eval=FALSE, code=reveal('{{chunk_name}}', {{the_break_points}}, {{the_highlighting}})}",
    "```",
    "]]",
    ".column[.content.center[",
    "```{r output_{{chunk_name}}_{{the_break_points}}, echo=FALSE, code=reveal('{{chunk_name}}', {{the_break_points}}, {{the_highlighting}})}",
    "```",
    "]]",
    .open = "{{", .close = "}}", .sep = "\n"
  )
  glue::glue_collapse(partial_knit_steps, "\n---\n")
  } else {
    
    partial_knit_steps <- glue::glue("```{r output_{{chunk_name}}_{{the_break_points}}, echo=FALSE, code=reveal('{{chunk_name}}', {{the_break_points}}, {{the_highlighting}})}",
    "```",
    .open = "{{", .close = "}}", .sep = "\n"
    )
    glue::glue_collapse(partial_knit_steps, "\n---\n")
    
  }
  
}


```


```{r}
partial_knit_chunks(chunk_name = "the_code", 
                    the_break_points = my_break_points, 
                    the_highlighting = my_highlighting, 
                    show_code = T)
```

```{r}
apply_reveal <- function(chunk_name, the_break_points, the_highlighting, show_code){
  paste(knitr::knit(text = partial_knit_chunks(chunk_name, the_break_points, the_highlighting, show_code = T)), collapse = "\n")
}
```


---

`r apply_reveal(chunk_name = "the_code", the_break_points = my_break_points, the_highlighting = my_highlighting, show_code = T)`





```{css, eval = TRUE, echo = F}
.remark-code{line-height: 1.5; font-size: 60%}
```
